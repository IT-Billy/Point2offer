package solution;

/**
 * 面试题49：丑数
 * 题目：我们把只包含质数因子2、3和5的数称作丑数（Ugly Number）。求按从小到
 * 大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。
 * 习惯上我们把1当做第一个丑数。
 */
public class UglyNumber {

    /**
     * 说下思路，如果p是丑数，那么p=2^x * 3^y * 5^z
     * 那么只要赋予x,y,z不同的值就能得到不同的丑数。
     * 如果要顺序找出丑数，要知道下面几个特点。
     * 对于任何丑数p：
     * （一）那么2*p,3*p,5*p都是丑数
     * （二）如果p<q, 那么2*p<2*q,3*p<3*q,5*p<5*q
     * 现在说说算法思想：
     * 由于1是最小的丑数，那么从1开始，把2*1，3*1，5*1，进行比较，
     * 得出最小的就是1的下一个丑数，也就是2*1，这个时候，多了一个丑数‘2’，
     * 也就又多了3个可以比较的丑数，2*2，3*2，5*2，这个时候就把之前‘1’生成的丑数和‘2’生成的丑数加进来
     * 也就是(3*1, 5*1, 2*2, 3*2, 5*2)进行比较，找出最小的为3*1。
     * 此时丑数序列为{1, 2, 3}，这时候多了一个丑数‘3’，也就又多了3个可以比较的丑数，2*3，3*3，5*3，
     * 这个时候就把之前‘1’生成的丑数和之前‘2’生成的丑数和‘3’生成的丑数加进来
     * 也就是(5*1, 2*2, 3*2, 5*2, 2*3, 3*3, 5*3)进行比较，找出最小的为2*2。
     * 如此循环下去就会发现，每次选进来一个丑数，该丑数又会生成3个新的丑数进行比较。
     * 其实我们不用这样子来把所有的数加进来再比较，既然有p<q, 那么2*p<2*q，3*p<3*q，5*p<5*q，
     * 如例子所示，如果此时丑数序列为{1, 2}，3*1<3*2，5*1<5*2，那么我们根本就不用把3*2和5*2加进来再选出小的，
     * 因为在他们前面，有比他们更小的3*1和5*1，所以只需要比较(2*2,3*1,5*1)。
     * 其实每次我们只用比较3个数：用于乘2的最小的数、用于乘3的最小的数，用于乘5的最小的数。
     * @param index
     * @return
     */
    public int getUglyNumber(int index) {

        if (index <= 0) {
            return 0;
        }

        if(index < 7) {
            return index;
        }

        // ret数组从小到大存放1-index之间的丑数
        int[] ret = new int[index];
        // 定义1为第一个丑数
        ret[0] = 1;
        // t2、t3、t5分别指向比较大小后的还未乘以2，3，5的最小丑数的下标
        // 例如现在丑数序列为{1, 2}，在1*2，1*3，1*5比较后并且选出1*2为最小之后，t2需要向前移动，然后再比较下一个丑数(此时t2指向的下标的数乘以2)和他们之间的大小
        int t2 = 0,t3 = 0,t5 = 0;
        for (int i = 1; i < index; i++) {
            // 选出最小值
            ret[i] = Math.min(Math.min(ret[t2] * 2, ret[t3] * 3), ret[t5] * 5);
            // 如果是之前被选出来的最小值，则对应的指针加1
            if (ret[i] == ret[t2] * 2) t2++;
            if (ret[i] == ret[t3] * 3) t3++;
            if (ret[i] == ret[t5] * 5) t5++;
        }

        return ret[index - 1];
    }

    public static void main(String[] args) {
        System.out.println(new UglyNumber().getUglyNumber(10));
    }
}
